"""Module for the gorgon_sim class."""
import glob
import os
import re
from warnings import warn

import numpy as np
import vtk
from vtk.util import numpy_support as vtk_np

"""
gorgon_import class for importing pvti files generated by Gorgon
Any issues, feel free to email me at: lars.mejnertsen10@imperial.ac.uk
"""


class gorgon_sim:
    """Class for loading Gorgon simulation data.

    Initialises a Gorgon simulation object, which contains methods for
    importing vtk files. This creates a list of all the available variables
    and timesteps in a given directory, as well as importing the grid. It
    determines this, as well as the index ("x24") and filetype ("pvtr")
    using a list of the vtk files in the directory. The index and filetype
    can also be specified.

    Args:
    ----
        data_dir (str): the directory in which all the files are located. This
            is optional for if you just want to use the methods in the class
            (e.g. vtk_import) without the extra features
        filetype (str): the filetype the data is in. If not specified, the
            filetype is found from the file list
        index (str): the index of the data (e.g. the x24 part in
            x24_rho-0.pvti). If not specified, the index is specified from the
            file list
        show_warnings (str): Displays warnings if they are raised

    """

    def __init__(
        self, data_dir=None, filetype=None, index=None, show_warnings=True, MS=True
    ):
        """Initialise the gorgon_sim class."""
        self.fdir = data_dir + "/MS/" if MS else data_dir

        self.arr = {}
        self.ftype = None

        ftype_regex = "?vt[ri]"
        index_regex = "*"

        self.warnings = show_warnings

        if filetype is not None:
            self.ftype = filetype

        if data_dir is not None:
            if filetype is None:
                self.ftype = ftype_regex
            else:
                self.ftype = filetype

            if index is None:
                self.index = index_regex
            else:
                self.index = index

            # Get list of files
            files = glob.glob(self.fdir + f"{os.sep}{self.index}_*." + self.ftype)

            if len(files) == 0:
                raise RuntimeError("No files found in directory: " f'"{data_dir}"')

            files = [file.split(os.sep)[-1] for file in files if "restart" not in file]
            # This removes restart files from file list

            if len(files) == 0:
                raise RuntimeError(
                    "Only restart files found in directory: " f'"{data_dir}"'
                )

            # Split file names
            #   Filenames are of form "index"_"arr_name"-"time"."filetype"
            #   Note: Regex magic, DO NOT TOUCH
            split_names = [
                re.split(r"(?=\w+)_(\w+\W*\w+)-(\d+).(\w+)", file) for file in files
            ]

            if index is None:
                # Index is the zeroth element in list
                index = np.unique([split[0] for split in split_names])
                if len(index) > 1:
                    if self.warnings:
                        warn(
                            f"\nMultiple indices have been found in"
                            f'"{self.fdir}": {index}.'
                            f"Defaulting to first in list: {index[0]}. If "
                            "other index is required, please specify in "
                            "arguments"
                        )
                self.index = index[0]

            if filetype is None:
                # Filetype is the second to last element in list
                filetype = np.unique([split[-2] for split in split_names])
                if len(filetype) > 1:
                    if self.warnings:
                        warn(
                            f"\nMultiple filetypes have been found in"
                            f'"{self.fdir}": {filetype}.'
                            f"Defaulting to first in list: {filetype[0]}. If "
                            "other filetype is required, please specify in "
                            "arguments"
                        )
                self.ftype = filetype[0]

            # Remove files with other indices and filetypes
            split_names = [
                split
                for split in split_names
                if split[0] == self.index and split[-2] == self.ftype
            ]

            # Array name is the 2nd element in list
            self.arr_names = np.unique([split[1] for split in split_names])

            # Timestep is 3rd element in list
            self.times = np.unique([int(split[2]) for split in split_names])
            self.times = np.sort(self.times)
            self.timesteps = np.arange(len(self.times))

            # Load the grid
            #   Can't use edge centred variables, they have extra cells
            for s in self.arr_names:
                if "vec" not in s:
                    break

            self.time = self.times[0]

            file_name = self._create_filename(s)
            self.import_space(file_name)

    def _create_filename(self, arr_name, time=None, filetype=None, nodir=False):
        """Create a filename of a particular array.

        Only the array name (arr_name) is specified, it uses the
        current timestep and filetype to create the filename. Otherwise, it
        uses what is specified

        Args:
        ----
            arr_name (str): the name of the data array (e.g. "rho1")
            time (str,int): the timestep to import
            filetype (str): to specify which vtk file, (p)vti or (p)vtr
            nodir (bool): choose whether to include or omit the full path to
                the file

        """
        if time is None:
            time = self.time

        if not isinstance(time, str):
            time = str(time)

        fdir = self.fdir + os.sep
        if nodir:
            fdir = ""

        if filetype is None:
            filetype = self.ftype

        if nodir:
            return f"{self.index}_{arr_name}-{time}.{filetype}"
        else:
            return f"{fdir}{self.index}_{arr_name}-{time}.{filetype}"

    def _get_vtk_data_reader(self, filetype=None):
        """Retrieve the correct vtk data reader.

        Retrieve the correct vtk data reader, depending on whether the
        filetype is (p)vti or (p)vtr).

        Arguments:
        ---------
            filetype (opt): to specify which vtk file, (p)vti or (p)vtr

        """
        if filetype is None:
            filetype = self.ftype

        if self.ftype == "pvti":
            return vtk.vtkXMLPImageDataReader()
        if self.ftype == "vti":
            return vtk.vtkXMLImageDataReader()
        if self.ftype == "pvtr":
            return vtk.vtkXMLPRectilinearGridReader()
        if self.ftype == "vtr":
            return vtk.vtkXMLRectilinearGridReader()

    def import_space(self, filename):
        """Import the grid positions and spacing information.

        Creates arrays for positions of the cell centre (xc, yc, zc), cell
        boundaries (xb, yb, zb), and cell size (spacing) (dx, dy, dz). For
        pvti/vti, it also creates spacing and center attributes.

        Args:
        ----
            filename (str): the path to the file used to import the space
                information

        """
        # If file not found, exit function
        if not os.path.isfile(filename):
            raise RuntimeWarning("Can't find file: " + filename)

        # Create vtk reader
        reader = self._get_vtk_data_reader()
        reader.SetFileName(filename)
        reader.Update()
        data = reader.GetOutput()

        if self.ftype == "pvti" or self.ftype == "vti":
            # For (p)vti, spacing info. is stored in Bounds and Spacing

            bounds = np.array(data.GetBounds())
            spacing = np.array(data.GetSpacing())

            self.spacing = spacing
            self.center = -np.array([bounds[0], bounds[2], bounds[4]])

            self.xb = np.arange(bounds[0], bounds[1] + spacing[0], spacing[0])
            self.yb = np.arange(bounds[2], bounds[3] + spacing[1], spacing[1])
            self.zb = np.arange(bounds[4], bounds[5] + spacing[2], spacing[2])

        elif self.ftype == "pvtr" or self.ftype == "vtr":
            # For (p)vtr, spacing info. is stored in the coordinates

            self.xb = vtk_np.vtk_to_numpy(data.GetXCoordinates())
            self.yb = vtk_np.vtk_to_numpy(data.GetYCoordinates())
            self.zb = vtk_np.vtk_to_numpy(data.GetZCoordinates())

            self.center = -np.array([self.xb[0], self.yb[0], self.zb[0]])

        else:
            raise RuntimeError(
                "Filetype not properly specified, must be "
                '"pvti", "vti", "pvtr" or "vtr". Try specifying'
                " the filetype in argument, "
                'e.g. gorgon_sim("data_dir", filetype="pvtr"'
            )

        self.xc = 0.5 * (self.xb[1:] + self.xb[:-1])
        self.yc = 0.5 * (self.yb[1:] + self.yb[:-1])
        self.zc = 0.5 * (self.zb[1:] + self.zb[:-1])

        self.dx = self.xb[1:] - self.xb[:-1]
        self.dy = self.yb[1:] - self.yb[:-1]
        self.dz = self.zb[1:] - self.zb[:-1]

    def import_timestep(self, timestep, arr_names=None, delete_existing=True):
        """Import the array data a given timestep.

        Array names can be specified to import only arrays of interest. If not
        specified, all arrays are imported. Data is stored in self.arr.

        Args:
        ----
            timestep (int): the timestep number to import
            arr_names (list(str), str): the name(s) of the arrays to import
            delete_existing (bool): if True, deletes arrays that are not
                imported.

        """
        self.time = self.times[timestep]
        if arr_names is None:
            arr_names = self.arr_names

        for s in self.arr_names:
            if s in arr_names and s != "IBc":
                filename = self._create_filename(s)
                self.import_vtk(filename, s)
            elif delete_existing and s in self.arr:
                del self.arr[s]

    def timestep(self, time):
        """Return the simulation timestep (index from 0) corresponding to a given time.

        Args:
        ----
            time (int): Simulation time in seconds.

        Raises:
        ------
            RuntimeWarning: Fails if there is no data for the given time.

        Returns:
        -------
            int: Timestep corresponding to the given time.

        """
        if not np.any(self.times == time):
            raise RuntimeWarning("Could not import timestep for time: " + str(time))
            return
        else:
            return np.where(self.times == time)[0][0]

    def import_vtk(self, filename, varname, log=False, output=False):
        """Import a vtk data file into a numpy array.

        Imports a vtk data file into a numpy array. This method is included to
        if you just want to load a vtk file, rather than going through the
        helper functions. This method is also called by the import_timestep
        method, for easy use.

        Args:
        ----
            filename (str): the name of the vtk file, may require full path
            varname (str): the name of the data array (e.g. "rho1")
            log (str): this transforms the data out of log, if require
            output (bool): if True, returns imported numpy array

        Returns:
        -------
            If output==False, returns nothing.
            Otherwise will return the numpy array with the imported vtk data.

        """
        if not os.path.isfile(filename) and self.warnings:
            warn("Can't find file: " + filename)
            return

        reader = self._get_vtk_data_reader()
        reader.SetFileName(filename)
        reader.Update()

        data = reader.GetOutput()
        dim = data.GetDimensions()

        v = vtk_np.vtk_to_numpy(data.GetCellData().GetArray(0))

        # If data in log, transform it
        if log:
            v = 10**v

        # Reshape the data into a 3D array
        #   4D if non scalar data (4th component is component)
        n_comp = data.GetCellData().GetArray(0).GetNumberOfComponents()
        vec = [int(i - 1) for i in dim]
        if n_comp > 1:
            vec.append(n_comp)

        self.arr[varname] = v.reshape(vec, order="F")

        if output:
            return self.arr[varname]

    def set_3D_axlim(self, ax):
        """Set the limits of a 3D pyplot axis to that of the simulation bounds.

        Args:
        ----
            ax (pyplot.axes): the 3D pyplot axes

        """
        ax.set(
            xlim=[self.xb[0], self.xb[-1]],
            ylim=[self.yb[0], self.yb[-1]],
            zlim=[self.zb[0], self.zb[-1]],
        )
        ax.set_aspect("equal")

    def write_vti_scalar(self, arr, x=None, y=None, z=None, name=None, output_dir=""):
        """Write a 3D numpy array into a VTI file.

        arr can be either string, np.array or
        dict. If string, array is written from self.arr. If np.array or dict,
        data is written from arr, assuming same size as self, unless x, y and z
        are specified. Only works for scalar values and uniform spacing
        (pvti/vti).

        Args:
        ----
            arr (str, np.array): the data you want to write, either from loaded
                from arr, or from self.arr
            x (np.array): the x grid position array.
            y (np.array): the y grid position array.
            z (np.array): the z grid position array.
            name (str): Name of the file/data array. Needed for np.array or
                dict array input
            output_dir (str): Specify a different output folder.

        """
        from pyevtk.hl import imageToVTK

        if output_dir != "":
            output_dir += os.sep

        if x is None:
            x = self.xb
            y = self.yb
            z = self.zb

        # If x, y, and z are different from the array
        d = np.array([x[1] - x[0], y[1] - y[0], z[1] - z[0]])
        xc = np.array([x[0], y[0], z[0]])  # -0.5*d

        if isinstance(arr, str):
            imageToVTK(
                f"{output_dir}{self.index}_{arr}-{self.time}",
                cellData={arr: self.arr[arr]},
                origin=xc.tolist(),
                spacing=d.tolist(),
            )

        else:
            if name is None:
                raise RuntimeError(
                    "For arr of type np.array or dict, you need" " to specify a name"
                )

            fname = f"{output_dir}{self.index}_{name}-{self.time}"

            if isinstance(arr, dict):
                imageToVTK(fname, cellData=arr, origin=xc.tolist(), spacing=d.tolist())

            elif type(arr) is np.array or type(arr) is np.ndarray:
                imageToVTK(
                    fname, cellData={name: arr}, origin=xc.tolist(), spacing=d.tolist()
                )

            else:
                raise ValueError(
                    "arr must be of type str, np.array, np.ndarray or dict"
                )
